<h1 align="center" style="font-weight: bold;">C√≥digo limpo: Habilidades Pr√°ticas de Agile Software</h1>

<div align="center">
  
<img src="https://m.media-amazon.com/images/I/51E2055ZGUL._AC_UF1000,1000_QL80_.jpg">

[Link](https://www.amazon.com.br/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) para acessar o livro

---

</div>
<h3 align="left">Sum√°rio üìÑ</h3>
<p align="left">
  <a href="#descricao">1. Descri√ß√£o üìù</a><br>
  <a href="#descricao">2. C√≥digo Limpo</a><br>
  <a href="#descricao">3. Nomes Significativos</a><br>
  <a href="#descricao">4. Fun√ß√µes</a><br>
  <a href="#descricao">5. Coment√°rios</a><br>
  <a href="#descricao">6. Formata√ß√£o</a><br>
  <a href="#descricao">7. Objetos e Estruturas de Dados</a><br>
  <a href="#descricao">8. Tratamento de Erro</a><br>
  <a href="#descricao">9. Limites</a><br>
  <a href="#descricao">10. Testes de Unidade</a><br>
  <a href="#descricao">11. Classes</a><br>
  <a href="#descricao">12. Sistemas</a><br>
</p>

---

<h2 id="descricao"> 2. C√≥digo Limpo</h2>

N√£o basta apenas escrever um c√≥digo que funcione; √© essencial mant√™-lo limpo e organizado. Com o tempo, c√≥digos podem se degradar se n√£o cuidarmos deles ativamente. Uma regra simples da organiza√ß√£o de escoteiros dos EUA nos ensina a deixar o acampamento mais limpo do que quando o encontramos, e podemos aplicar essa ideia ao nosso trabalho: sempre deixe o c√≥digo melhor do que o encontrou. Pequenas melhorias, como renomear vari√°veis para torn√°-las mais claras ou simplificar fun√ß√µes, podem prevenir a deteriora√ß√£o do c√≥digo. Imagine trabalhar em um projeto onde o c√≥digo melhora continuamente. Isso n√£o √© parte do profissionalismo?

---

<h2 id="descricao"> 3. Nomes Significativos</h2>

Nomes no c√≥digo devem ser claros e significativos, refletindo seu prop√≥sito sem a necessidade de coment√°rios. Bons nomes tornam o c√≥digo mais f√°cil de entender e mant√™m a complexidade baixa. Ao lidar com listas, por exemplo, prefira nomes descritivos como gameBoard para uma lista de c√©lulas e getFlaggedCells() para uma fun√ß√£o que retorna c√©lulas marcadas.

Evite nomes que possam causar confus√£o ou contenham informa√ß√µes erradas, como vari√°veis ou classes com nomes semelhantes. Prefira nomes que sejam f√°ceis de buscar e usar no c√≥digo, evitando nomes curtos e confusos, especialmente em escopos amplos. Exemplo:

```javascript
// Ruim:
setTimeout(blastOff, 86400000);

// Melhor:
const MILLISECONDS_PER_DAY = 86400000;
setTimeout(blastOff, MILLISECONDS_PER_DAY);
```

Para classes, use substantivos como Customer ou Account, enquanto m√©todos devem ser nomeados com verbos que descrevem suas a√ß√µes, como save, delete, ou getName. Ao nomear interfaces e implementa√ß√µes, evite prefixos desnecess√°rios como "I", e mantenha os nomes simples e descritivos. Exemplo:

```javascript
// Ruim:
class Processador {
  save() { /* ... */ }
}

// Melhor:
class UserAccount {
  save() { /* ... */ }
}
```

Contexto √© essencial. Nomes devem ser claros dentro de seu escopo, como no exemplo de uma classe Address que agrupa vari√°veis relacionadas a um endere√ßo. Evite prefixos redundantes que tornam o c√≥digo prolixo e desnecessariamente longo. Prefira vari√°veis explicativas e substitua n√∫meros "m√°gicos" por constantes com nomes significativos, como MILLISECONDS_PER_DAY em vez de 86400000. Exemplo:

```javascript
class Address {
  constructor(firstName, lastName, street, houseNumber, city, state, zipcode) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.street = street;
    this.houseNumber = houseNumber;
    this.city = city;
    this.state = state;
    this.zipcode = zipcode;
  }
}

const address = new Address("John", "Doe", "Main St", "123", "Springfield", "IL", "62701");
console.log(address.state);
```

Em loops e fun√ß√µes, use nomes descritivos para par√¢metros, evitando mapeamentos mentais. Finalmente, ao inv√©s de usar curto-circuito para definir valores padr√µes, utilize argumentos padr√µes em fun√ß√µes para garantir maior clareza.

---

<h2 id="descricao"> 4. Fun√ß√µes</h2>

Fun√ß√µes devem ser pequenas e realizar apenas uma tarefa, facilitando a compreens√£o e a manuten√ß√£o. Elas devem ter poucos par√¢metros, preferencialmente zero, e evitar m√∫ltiplos n√≠veis de abstra√ß√£o. Nomes descritivos ajudam a entender o c√≥digo sem precisar de coment√°rios.

Limitar o n√∫mero de par√¢metros √© crucial para facilitar o teste e evitar complexidade. Fun√ß√µes com mais de dois par√¢metros devem preferir objetos ou usar desestrutura√ß√£o para melhorar a clareza.

Estruturas como switch devem ser usadas com cautela e encapsuladas em classes, enquanto blocos try/catch devem ser extra√≠dos para manter a l√≥gica clara. Efeitos colaterais, como modificar estados externos, devem ser evitados. Exce√ß√µes s√£o prefer√≠veis a c√≥digos de erro, separando o fluxo de tratamento de erros da l√≥gica principal.

Em resumo as fun√ß√µes devem fazer apenas uma coisa, o nome deve descrever a a√ß√£o, evitar efeitos colaterais e flags como par√¢metro.

**Exemplo ruim:**
```javascript
function handleUserUpdate(user, updateType, isAdmin) {
  if (isAdmin) {
    if (updateType === 'password') {
      user.password = 'newPassword123';
      console.log(`Password updated for user: ${user.name}`);
    } else if (updateType === 'email') {
      user.email = 'newemail@example.com';
      console.log(`Email updated for user: ${user.name}`);
    }
  } else {
    console.log('User does not have admin privileges to update.');
  }

  if (updateType === 'notify') {
    console.log('Sending notification to user...');
    user.notifications.push('Notification sent!');
  }
}
```

**Problemas:** A fun√ß√£o faz v√°rias coisas (atualiza senha, email e notifica o usu√°rio), usa isAdmin como flag, levando a m√∫ltiplos caminhos de c√≥digo, tem efeitos colaterais (modifica diretamente o objeto user e seu estado), o c√≥digo est√° duplicado na l√≥gica de atualiza√ß√£o e o nome n√£o descreve claramente a a√ß√£o da fun√ß√£o.

---

**Jeito correto segundo clean code:**
```javascript
function updateUserPassword(user, newPassword) {
  user.password = newPassword;
  logUpdate('Password', user);
}

function updateUserEmail(user, newEmail) {
  user.email = newEmail;
  logUpdate('Email', user);
}

function logUpdate(updateType, user) {
  console.log(`${updateType} updated for user: ${user.name}`);
}

function notifyUser(user) {
  console.log('Sending notification to user...');
  user.notifications = [...user.notifications, 'Notification sent!'];
}

function handleUserUpdate(user, updateType, isAdmin = false) {
  if (!isAdmin) {
    console.log('User does not have admin privileges to update.');
    return;
  }

  switch (updateType) {
    case 'password':
      updateUserPassword(user, 'newPassword123');
      break;
    case 'email':
      updateUserEmail(user, 'newemail@example.com');
      break;
    case 'notify':
      notifyUser(user);
      break;
    default:
      console.log('Invalid update type');
  }
}
```
**Melhorias:** faz apenas uma coisa por fun√ß√£o, o nome est√° descritivo, sem efeitos colaterais, sem flags desnecess√°rias e o c√≥digo duplicado foi removido.

---

<h2 id="descricao"> 5. Coment√°rios</h2>

Coment√°rios devem ser evitados sempre que o c√≥digo puder ser autoexplicativo. Refatorar o c√≥digo para torn√°-lo claro √© prefer√≠vel a adicionar coment√°rios explicativos. Nomes descritivos para fun√ß√µes, vari√°veis e classes podem substituir a maioria dos coment√°rios, tornando o c√≥digo mais leg√≠vel e menos propenso a se tornar desatualizado.

Coment√°rios s√≥ s√£o √∫teis em casos de l√≥gica de neg√≥cio complexa ou para alertar sobre algo espec√≠fico e potencialmente problem√°tico. Coment√°rios como TODO podem ser usados para marcar √°reas que precisam de aten√ß√£o futura.

Evite manter c√≥digo comentado na base de c√≥digo e n√£o registre altera√ß√µes diretamente nos coment√°rios, pois o controle de vers√£o j√° lida com isso. N√£o use marcadores de posi√ß√£o, como linhas de divis√£o, para separar se√ß√µes do c√≥digo.

**Exemplo ruim:**

```javascript
function calculateHash(data) {
  // Cria uma hash
  let hash = 0;

  // Comprimento da string
  const length = data.length;

  // Loop em cada caractere
  for (let i = 0; i < length; i++) {
    // Pega o c√≥digo do caractere
    const char = data.charCodeAt(i);
    // Gera a hash
    hash = ((hash << 5) - hash) + char;
    // Converte para inteiro 32-bit
    hash &= hash;
  }

  // TODO: adicionar suporte a outras codifica√ß√µes
  return hash;
}

// doSomeWork();
// doOtherStuff();  // c√≥digo desnecess√°rio comentado

/**
 * 2023-08-17: Adicionada fun√ß√£o de hash (TS)
 * 2023-07-22: Melhorada fun√ß√£o de hash (JP)
 */
function combine(a, b) {
  return a + b;
}

////////////////////////////////////////////////////////////////////////////////
// Configura√ß√£o inicial do sistema
////////////////////////////////////////////////////////////////////////////////
const config = {
  retries: 5,
  timeout: 2000
};
```
**Problemas:** coment√°rios explicando o √≥bvio (como "Cria uma hash"), c√≥digo comentado deixado na base de c√≥digo, registro de altera√ß√µes desnecess√°rio e marcadores de posi√ß√£o sem valor real


---

**Jeito correto segundo clean code:**
```javascript
function calculateHash(data) {
  let hash = 0;
  const length = data.length;

  for (let i = 0; i < length; i++) {
    const char = data.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash &= hash;  // Converte para 32-bit
  }

  return hash;
}

function combine(a, b) {
  return a + b;
}

const config = {
  retries: 5,
  timeout: 2000
};
```

**Melhorias:** sem coment√°rios desnecess√°rios, remo√ß√£o do c√≥digo comentado, sem registros de altera√ß√µes no c√≥digo e elimina√ß√£o de mercadores de posi√ß√£o.

---

<h2 id="descricao"> 6. Formata√ß√£o </h2>

A formata√ß√£o √© essencial para garantir um c√≥digo leg√≠vel e profissional. Um c√≥digo bem formatado facilita a leitura, a manuten√ß√£o e reflete o cuidado do desenvolvedor. Arquivos menores, bem divididos, s√£o mais f√°ceis de gerenciar. Ferramentas autom√°ticas de formata√ß√£o, como linters e formatadores, s√£o recomendadas para evitar discuss√µes desnecess√°rias sobre estilo.

Seja consistente com a capitaliza√ß√£o em vari√°veis, fun√ß√µes e classes. Fun√ß√µes e chamadas de fun√ß√µes devem estar pr√≥ximas verticalmente para facilitar a leitura, respeitando o fluxo natural de leitura de cima para baixo.

**Exemplo ruim:**

```javascript
const ITEMS_IN_CART = 3;
const items_in_stock = 50;

const products = ['Laptop', 'Smartphone', 'Headphones'];
const Categories = ['Electronics', 'Accessories', 'Home Appliances'];

function place_order() {}
function cancel_order() {}

class user {}
class Order {}

class OrderManager {
  constructor(order) {
    this.order = order;
  }

  checkStock() {
    return db.lookup(this.order, 'stock');
  }

  getOrderDetails() {
    const stock = this.checkStock();
    // ...
  }

  processOrder() {
    this.getOrderDetails();
    this.sendInvoice();
    this.updateStock();
  }

  sendInvoice() {
    // ...
  }

  updateStock() {
    const stock = this.checkStock();
  }
}

const orderManager = new OrderManager(order);
orderManager.processOrder();
```

**Problemas:** inconsist√™ncia na capitaliza√ß√£o de vari√°veis, fun√ß√µes e classes, fun√ß√µes e chamadas de fun√ß√µes est√£o separadas, dificultando a leitura do fluxo, e a fun√ß√£o processOrder deveria estar mais pr√≥xima de suas depend√™ncias.

---

**Jeito correto segundo clean code:**
```javascript
const ITEMS_IN_CART = 3;
const ITEMS_IN_STOCK = 50;

const PRODUCTS = ['Laptop', 'Smartphone', 'Headphones'];
const CATEGORIES = ['Electronics', 'Accessories', 'Home Appliances'];

function placeOrder() {}
function cancelOrder() {}

class User {}
class Order {}

class OrderManager {
  constructor(order) {
    this.order = order;
  }

  processOrder() {
    this.getOrderDetails();
    this.sendInvoice();
    this.updateStock();
  }

  getOrderDetails() {
    const stock = this.checkStock();
    // ...
  }

  checkStock() {
    return db.lookup(this.order, 'stock');
  }

  sendInvoice() {
    // ...
  }

  updateStock() {
    const stock = this.checkStock();
    // ...
  }
}

const orderManager = new OrderManager(order);
orderManager.processOrder();
```

**Melhorias:** A capitaliza√ß√£o est√° consistente, teve um uso adequado de mai√∫sculas e min√∫sculas nas vari√°veis, fun√ß√µes e classes, como ITEMS_IN_STOCK e placeOrder. A fun√ß√£o processOrder est√° diretamente acima das fun√ß√µes auxiliares que ela utiliza, como getOrderDetails, sendInvoice, e updateStock, facilitando o fluxo de leitura. O c√≥digo segue uma estrutura l√≥gica de cima para baixo, refletindo um fluxo claro e f√°cil de entender.

---

<h2 id="descricao"> 7. Objetos e Estruturas de Dados </h2>

Objetos exp√µem as a√ß√µes e ocultam os dados, o que facilita a adi√ß√£o de novos tipos de objetos sem precisar modificar as a√ß√µes existentes, mas torna mais dif√≠cil a inclus√£o de novas atividades em objetos j√° existentes. Por outro lado, estruturas de dados exp√µem os dados e n√£o possuem a√ß√µes significativas, facilitando a adi√ß√£o de novas a√ß√µes √†s estruturas de dados existentes, mas dificultando a inclus√£o de novas estruturas de dados em fun√ß√µes existentes.

Em um sistema, a escolha entre objetos e estruturas de dados depende da flexibilidade desejada. Quando se busca flexibilidade para adicionar novos tipos de dados, a op√ß√£o por objetos √© mais adequada. Quando a necessidade √© adicionar novas a√ß√µes, optar por tipos de dados e procedimentos faz mais sentido.

Utilizar getters e setters em objetos √© uma pr√°tica recomendada porque oferece v√°rias vantagens, como facilitar a modifica√ß√£o do comportamento dos acessos aos dados sem alterar os pontos de chamada no c√≥digo, permite adicionar valida√ß√µes ao definir valores (set), por encapsular a representa√ß√£o interna dos dados promove maior flexibilidade, e torna mais f√°cil adicionar logs e tratamentos de erros.

Exemplo ruim:
```javascript
function createProduct() {
  return {
    stock: 0, // Propriedade p√∫blica
  };
}

const product = createProduct();
product.stock = 50; // Modifica√ß√£o direta
```

Jeito correto segundo clean code:
```javascript
function createProduct() {
  // Propriedade privada
  let stock = 0;

  // Getter para acessar o estoque
  function getStock() {
    return stock;
  }

  // Setter para modificar o estoque, com valida√ß√£o
  function setStock(quantity) {
    if (quantity < 0) {
      throw new Error("A quantidade de estoque n√£o pode ser negativa");
    }
    stock = quantity;
  }

  return {
    getStock,
    setStock,
  };
}

const product = createProduct();
product.setStock(50); // Modifica√ß√£o controlada
console.log(product.getStock()); // Acesso controlado
```

---

<h2 id="descricao"> 8. Tratamento de Erro </h2>

No passado, quando as linguagens de programa√ß√£o n√£o suportavam exce√ß√µes, era comum utilizar flags ou c√≥digos de erro para indicar problemas, o que obrigava o chamador a verificar esses erros ap√≥s cada chamada. Esse m√©todo resultava em c√≥digo confuso e propenso a erros, j√° que os programadores podiam facilmente esquecer de verificar os erros.

**Exemplo sem Exce√ß√µes:**

```javascript
function sendShutDown() {
    const handle = getHandle(DEV1);
    if (handle !== INVALID_HANDLE) {
        const record = retrieveDeviceRecord(handle);
        if (record.status !== DEVICE_SUSPENDED) {
            pauseDevice(handle);
            clearDeviceWorkQueue(handle);
            closeDevice(handle);
        } else {
            console.log("Device suspended. Unable to shut down");
        }
    } else {
        console.log("Invalid handle for:", DEV1);
    }
}
```

**Exemplo com Exce√ß√µes:**

```javascript
function sendShutDown() {
    try {
        tryToShutDown();
    } catch (error) {
        console.error(error.message);
    }
}

function tryToShutDown() {
    const handle = getHandle(DEV1);
    if (handle === INVALID_HANDLE) {
        throw new Error("Invalid handle for: " + DEV1);
    }

    const record = retrieveDeviceRecord(handle);
    if (record.status === DEVICE_SUSPENDED) {
        throw new Error("Device suspended. Unable to shut down");
    }

    pauseDevice(handle);
    clearDeviceWorkQueue(handle);
    closeDevice(handle);
}
```

Nesse exemplo, o c√≥digo principal (tryToShutDown) √© separado do tratamento de erros (catch), tornando a l√≥gica mais clara e o c√≥digo mais f√°cil de manter.

---

Retornar null de fun√ß√µes ou passar null como argumento √© uma pr√°tica que deve ser evitada, pois isso pode levar a erros em tempo de execu√ß√£o, como NullPointerException. Em vez de retornar null, √© melhor lan√ßar uma exce√ß√£o ou usar um padr√£o de caso especial que retorne um objeto com um comportamento padr√£o.

```javascript
function registerItem(item) {
    if (item !== null) {
        const registry = persistentStore.getItemRegistry();
        if (registry !== null) {
            const existing = registry.getItem(item.getID());
            if (existing.getBillingPeriod().hasRetailOwner()) {
                existing.register(item);
            }
        }
    }
}

```

Esse c√≥digo √© propenso a erros porque depende de v√°rias verifica√ß√µes de null.

**Refatora√ß√£o com Objetos de Caso Especial:**

```javascript
function getItemRegistry() {
    return persistentStore.getItemRegistry() || new NullRegistry();
}

function getItem(itemID) {
    return registry.getItem(itemID) || new NullItem();
}
```

Agora, getItemRegistry e getItem sempre retornam um objeto v√°lido, eliminando a necessidade de verifica√ß√µes de null.

Evitar tamb√©m passar null para fun√ß√µes √© ainda mais importante. Se uma fun√ß√£o depende de argumentos n√£o nulos, considere usar uma exce√ß√£o ou valida√ß√£o antecipada.

---

<h2 id="descricao"> 9. Limites </h2>

Quando usamos bibliotecas de terceiros, √© essencial entender como elas funcionam e como podemos integr√°-las de forma eficaz ao nosso c√≥digo. Em vez de apenas ler a documenta√ß√£o ou tentar integrar o c√≥digo diretamente, podemos criar "testes de aprendizagem" para explorar o comportamento dessas APIs e entender melhor como elas funcionam.

**Exemplo de Teste de Aprendizagem:**

Suponha que queremos usar a biblioteca winston para logging. Podemos come√ßar criando um teste simples para verificar se a configura√ß√£o b√°sica funciona conforme esperado.

**Teste Inicial:**

```javascript
const winston = require('winston');

// Teste simples para verificar o funcionamento b√°sico do logger
function testLogCreate() {
    const logger = winston.createLogger({
        level: 'info',
        transports: [
            new winston.transports.Console()
        ]
    });

    logger.info('hello');
}

testLogCreate();

```

Ap√≥s verificar que o logger b√°sico funciona, podemos testar outras configura√ß√µes, como formatos personalizados de sa√≠da:

```javascript
function testLogWithCustomFormat() {
    const logger = winston.createLogger({
        level: 'info',
        format: winston.format.combine(
            winston.format.colorize(),
            winston.format.timestamp(),
            winston.format.printf(({ timestamp, level, message }) => {
                return `${timestamp} ${level}: ${message}`;
            })
        ),
        transports: [
            new winston.transports.Console()
        ]
    });

    logger.info('hello with custom format');
}

testLogWithCustomFormat();
```

Depois de explorar e aprender como a biblioteca funciona, podemos encapsular esse conhecimento em uma fun√ß√£o ou classe para uso em toda a aplica√ß√£o, mantendo a l√≥gica de configura√ß√£o separada e reutiliz√°vel:

```javascript
function createLogger() {
    return winston.createLogger({
        level: 'info',
        format: winston.format.combine(
            winston.format.colorize(),
            winston.format.timestamp(),
            winston.format.printf(({ timestamp, level, message }) => {
                return `${timestamp} ${level}: ${message}`;
            })
        ),
        transports: [
            new winston.transports.Console()
        ]
    });
}

const logger = createLogger();
logger.info('Logger is ready to use across the application.');
```

---

<h2 id="descricao"> 10. Testes de Unidade </h2>

Os testes de unidade bem escritos e mantidos s√£o a chave para manter o c√≥digo de produ√ß√£o flex√≠vel e f√°cil de modificar. Testes robustos permitem que os desenvolvedores fa√ßam altera√ß√µes no c√≥digo com confian√ßa, sabendo que qualquer erro ser√° rapidamente detectado. Isso, por sua vez, facilita a manuten√ß√£o da arquitetura do c√≥digo e permite melhorias cont√≠nuas.

A qualidade mais importante em um teste √© a legibilidade. Testes leg√≠veis s√£o claros, simples e consistentes, facilitando a compreens√£o e a manuten√ß√£o. A clareza e a simplicidade nos testes permitem que eles transmitam seu prop√≥sito de forma direta, sem sobrecarregar o leitor com detalhes desnecess√°rios.

Considere testes que t√™m c√≥digo duplicado ou excesso de detalhes que obscurecem o objetivo do teste. Um exemplo t√≠pico seria testes com muitas chamadas repetidas ou detalhes que n√£o contribuem para a compreens√£o do teste. Refatorar esses testes para eliminar duplica√ß√£o e tornar a inten√ß√£o mais clara √© essencial para manter a qualidade.

---

Os testes limpos seguem cinco princ√≠pios essenciais:

- R√°pidos (Fast): Devem ser r√°pidos para incentivar execu√ß√µes frequentes e detec√ß√£o precoce de problemas.

- Independentes (Independent): Devem rodar de forma independente, sem depender de outros testes.

- Repet√≠veis (Repeatable): Precisam ser repet√≠veis em qualquer ambiente, garantindo consist√™ncia nos resultados.

- Autovalidados (Self-Validating): Devem retornar um resultado claro (passou/falhou) sem necessidade de verifica√ß√£o manual.

- Pontuais (Timely): Devem ser escritos no momento certo, de prefer√™ncia antes do c√≥digo de produ√ß√£o, para garantir testabilidade.

---

<h2 id="descricao"> 11. Classes </h2>

As classes devem ser pequenas e focadas em uma √∫nica responsabilidade, seguindo o Princ√≠pio da Responsabilidade √önica (SRP). Isso significa que uma classe deve ter apenas um motivo para mudar, e se houver m√∫ltiplas raz√µes para altera√ß√£o, deve-se considerar dividir a classe. Por exemplo, m√©todos que lidam com diferentes aspectos de um sistema podem ser extra√≠dos em classes menores e mais espec√≠ficas, assim como no exemplo da SuperDashboard e a extra√ß√£o de responsabilidades relacionadas √† vers√£o para uma nova classe.

Na organiza√ß√£o das classes em JavaScript, as vari√°veis privadas (usando o # para encapsulamento) devem ser declaradas no in√≠cio, seguidas de m√©todos p√∫blicos e privados. M√©todos que fazem parte de um comportamento comum devem ser colocados pr√≥ximos uns dos outros, de modo que o c√≥digo seja lido de cima para baixo, mantendo uma organiza√ß√£o l√≥gica e facilitando a leitura.

A coes√£o tamb√©m √© essencial. Cada m√©todo de uma classe deve manipular uma ou mais vari√°veis da inst√¢ncia. Quando os m√©todos compartilham muitas vari√°veis, isso sugere que a classe √© coesa. Por√©m, se as vari√°veis e m√©todos se tornam independentes entre si, a classe perde coes√£o e deve ser dividida. Um exemplo seria uma classe Stack, onde todos os m√©todos manipulam diretamente as vari√°veis de inst√¢ncia, garantindo coes√£o.

Para manter o c√≥digo mais isolado de altera√ß√µes, o uso de interfaces ou classes abstratas (em JavaScript, interfaces podem ser simuladas com classes ou tipos) pode ajudar a separar o comportamento de detalhes de implementa√ß√£o. Isso evita que mudan√ßas em detalhes concretos afetem outras partes do sistema.

---

<h2 id="descricao"> 12. Sistemas </h2>

> "Complexidade mata. Ela suga a vida dos desenvolvedores, dificulta o planejamento, a constru√ß√£o e o teste dos produtos‚Äù.
> ‚ÄîRay Ozzie, CTO, Microsoft Corporation

Assim como na analogia de construir uma cidade, onde diferentes equipes gerenciam partes espec√≠ficas, em software, devemos dividir responsabilidades entre diferentes m√≥dulos e classes. Essa abordagem modular facilita o desenvolvimento, manuten√ß√£o e crescimento do sistema.

Em JavaScript, √© importante separar a constru√ß√£o dos objetos e o uso do sistema. Uma boa pr√°tica √© mover a inicializa√ß√£o e configura√ß√£o de depend√™ncias para uma camada externa, geralmente o arquivo principal (main) ou uma fun√ß√£o de inicializa√ß√£o. Esse arquivo √© respons√°vel por instanciar objetos e passar depend√™ncias para o restante do sistema, mantendo o c√≥digo de l√≥gica de neg√≥cios separado da l√≥gica de inicializa√ß√£o.

Um exemplo seria usar um factory para criar objetos, em vez de instanci√°-los diretamente no c√≥digo principal. Isso mant√©m o sistema desacoplado dos detalhes de implementa√ß√£o da constru√ß√£o dos objetos, permitindo mais flexibilidade. Exemplo:

```javascript
class LineItem {
  constructor(product, quantity) {
    this.product = product;
    this.quantity = quantity;
  }
}

class Order {
  constructor() {
    this.items = [];
  }

  addItem(item) {
    this.items.push(item);
  }
}

class LineItemFactory {
  create(product, quantity) {
    return new LineItem(product, quantity);
  }
}

// No main, fazemos a separa√ß√£o
const factory = new LineItemFactory();
const order = new Order();
order.addItem(factory.create('Product A', 10));
```

Nesse exemplo, a responsabilidade de criar LineItem foi movida para LineItemFactory, separando a l√≥gica de cria√ß√£o da l√≥gica de uso no Order.

---

A Inje√ß√£o de Depend√™ncia (DI) √© uma t√©cnica poderosa para desacoplar depend√™ncias. Em JavaScript, frameworks como NestJS e InversifyJS suportam DI nativamente, mas tamb√©m podemos implement√°-la manualmente. O DI permite que as depend√™ncias sejam passadas para uma classe por meio de seu construtor ou setters, em vez de serem criadas dentro da pr√≥pria classe, promovendo flexibilidade e testabilidade.

Sistemas podem come√ßar simples e crescer conforme as necessidades mudam. No in√≠cio, podemos adotar uma arquitetura m√≠nima e aumentar a complexidade conforme a demanda cresce. Essa pr√°tica segue a filosofia √°gil de desenvolver **iterativamente**, refatorando e melhorando o sistema √† medida que novas funcionalidades s√£o adicionadas. O objetivo √© implementar apenas o que √© necess√°rio hoje, sabendo que refatora√ß√µes far√£o parte do processo de crescimento.

Padr√µes como Factory e Dependency Injection s√£o amplamente usados porque facilitam a reutiliza√ß√£o e a manuten√ß√£o do c√≥digo. No entanto, √© importante us√°-los quando trazem valor real ao projeto. N√£o devemos adotar padr√µes complexos apenas por serem populares, mas sim quando eles simplificam a implementa√ß√£o ou oferecem vantagens claras para o sistema.

---