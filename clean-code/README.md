<h1 align="center" style="font-weight: bold;">C√≥digo limpo: Habilidades Pr√°ticas de Agile Software</h1>

<div align="center">
  
<img src="https://m.media-amazon.com/images/I/51E2055ZGUL._AC_UF1000,1000_QL80_.jpg">

[Link](https://www.amazon.com.br/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) para acessar o livro

---

</div>
<h3 align="left">Sum√°rio üìÑ</h3>
<p align="left">
  <a href="#descricao">1. Descri√ß√£o üìù</a><br>
  <a href="#descricao">2. C√≥digo Limpo</a><br>
  <a href="#descricao">3. Nomes Significativos</a><br>
  <a href="#descricao">4. Fun√ß√µes</a><br>
  <a href="#descricao">5. Coment√°rios</a><br>
  <a href="#descricao">6. Formata√ß√£o</a><br>
  <a href="#descricao">7. Objetos e Estruturas de Dados</a><br>
  <a href="#descricao">8. Tratamento de Erro</a><br>
  <a href="#descricao">9. Limites</a><br>
  <a href="#descricao">10. Testes de Unidade</a><br>
  <a href="#descricao">11. Classes</a><br>
  <a href="#descricao">12. Sistemas</a><br>
  <a href="#descricao">13. Emerg√™ncia</a><br>
  <a href="#descricao">14. Concorr√™ncia</a><br>
</p>

---

<h2 id="descricao"> 2. C√≥digo Limpo</h2>

N√£o basta apenas escrever um c√≥digo que funcione; √© essencial mant√™-lo limpo e organizado. Com o tempo, c√≥digos podem se degradar se n√£o cuidarmos deles ativamente. Uma regra simples da organiza√ß√£o de escoteiros dos EUA nos ensina a deixar o acampamento mais limpo do que quando o encontramos, e podemos aplicar essa ideia ao nosso trabalho: sempre deixe o c√≥digo melhor do que o encontrou. Pequenas melhorias, como renomear vari√°veis para torn√°-las mais claras ou simplificar fun√ß√µes, podem prevenir a deteriora√ß√£o do c√≥digo. Imagine trabalhar em um projeto onde o c√≥digo melhora continuamente. Isso n√£o √© parte do profissionalismo?

<img src="http://www.osnews.com/images/comics/wtfm.jpg">

---

<h2 id="descricao"> 3. Nomes Significativos</h2>

Nomes no c√≥digo devem ser claros e significativos, refletindo seu prop√≥sito sem a necessidade de coment√°rios. Bons nomes tornam o c√≥digo mais f√°cil de entender e mant√™m a complexidade baixa. Ao lidar com listas, por exemplo, prefira nomes descritivos como gameBoard para uma lista de c√©lulas e getFlaggedCells() para uma fun√ß√£o que retorna c√©lulas marcadas.

Evite nomes que possam causar confus√£o ou contenham informa√ß√µes erradas, como vari√°veis ou classes com nomes semelhantes. Prefira nomes que sejam f√°ceis de buscar e usar no c√≥digo, evitando nomes curtos e confusos, especialmente em escopos amplos. Exemplo:

```javascript
// Ruim:
setTimeout(blastOff, 86400000);

// Melhor:
const MILLISECONDS_PER_DAY = 86400000;
setTimeout(blastOff, MILLISECONDS_PER_DAY);
```

Para classes, use substantivos como Customer ou Account, enquanto m√©todos devem ser nomeados com verbos que descrevem suas a√ß√µes, como save, delete, ou getName. Ao nomear interfaces e implementa√ß√µes, evite prefixos desnecess√°rios como "I", e mantenha os nomes simples e descritivos. Exemplo:

```javascript
// Ruim:
class Processador {
  save() { /* ... */ }
}

// Melhor:
class UserAccount {
  save() { /* ... */ }
}
```

Contexto √© essencial. Nomes devem ser claros dentro de seu escopo, como no exemplo de uma classe Address que agrupa vari√°veis relacionadas a um endere√ßo. Evite prefixos redundantes que tornam o c√≥digo prolixo e desnecessariamente longo. Prefira vari√°veis explicativas e substitua n√∫meros "m√°gicos" por constantes com nomes significativos, como MILLISECONDS_PER_DAY em vez de 86400000. Exemplo:

```javascript
class Address {
  constructor(firstName, lastName, street, houseNumber, city, state, zipcode) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.street = street;
    this.houseNumber = houseNumber;
    this.city = city;
    this.state = state;
    this.zipcode = zipcode;
  }
}

const address = new Address("John", "Doe", "Main St", "123", "Springfield", "IL", "62701");
console.log(address.state);
```

Em loops e fun√ß√µes, use nomes descritivos para par√¢metros, evitando mapeamentos mentais. Finalmente, ao inv√©s de usar curto-circuito para definir valores padr√µes, utilize argumentos padr√µes em fun√ß√µes para garantir maior clareza.

---

<h2 id="descricao"> 4. Fun√ß√µes</h2>

Fun√ß√µes devem ser pequenas e realizar apenas uma tarefa, facilitando a compreens√£o e a manuten√ß√£o. Elas devem ter poucos par√¢metros, preferencialmente zero, e evitar m√∫ltiplos n√≠veis de abstra√ß√£o. Nomes descritivos ajudam a entender o c√≥digo sem precisar de coment√°rios.

Limitar o n√∫mero de par√¢metros √© crucial para facilitar o teste e evitar complexidade. Fun√ß√µes com mais de dois par√¢metros devem preferir objetos ou usar desestrutura√ß√£o para melhorar a clareza.

Estruturas como switch devem ser usadas com cautela e encapsuladas em classes, enquanto blocos try/catch devem ser extra√≠dos para manter a l√≥gica clara. Efeitos colaterais, como modificar estados externos, devem ser evitados. Exce√ß√µes s√£o prefer√≠veis a c√≥digos de erro, separando o fluxo de tratamento de erros da l√≥gica principal.

Em resumo as fun√ß√µes devem fazer apenas uma coisa, o nome deve descrever a a√ß√£o, evitar efeitos colaterais e flags como par√¢metro.

**Exemplo ruim:**
```javascript
function handleUserUpdate(user, updateType, isAdmin) {
  if (isAdmin) {
    if (updateType === 'password') {
      user.password = 'newPassword123';
      console.log(`Password updated for user: ${user.name}`);
    } else if (updateType === 'email') {
      user.email = 'newemail@example.com';
      console.log(`Email updated for user: ${user.name}`);
    }
  } else {
    console.log('User does not have admin privileges to update.');
  }

  if (updateType === 'notify') {
    console.log('Sending notification to user...');
    user.notifications.push('Notification sent!');
  }
}
```

**Problemas:** A fun√ß√£o faz v√°rias coisas (atualiza senha, email e notifica o usu√°rio), usa isAdmin como flag, levando a m√∫ltiplos caminhos de c√≥digo, tem efeitos colaterais (modifica diretamente o objeto user e seu estado), o c√≥digo est√° duplicado na l√≥gica de atualiza√ß√£o e o nome n√£o descreve claramente a a√ß√£o da fun√ß√£o.

---

**Exemplo correto segundo clean code:**
```javascript
function updateUserPassword(user, newPassword) {
  user.password = newPassword;
  logUpdate('Password', user);
}

function updateUserEmail(user, newEmail) {
  user.email = newEmail;
  logUpdate('Email', user);
}

function logUpdate(updateType, user) {
  console.log(`${updateType} updated for user: ${user.name}`);
}

function notifyUser(user) {
  console.log('Sending notification to user...');
  user.notifications = [...user.notifications, 'Notification sent!'];
}

function handleUserUpdate(user, updateType, isAdmin = false) {
  if (!isAdmin) {
    console.log('User does not have admin privileges to update.');
    return;
  }

  switch (updateType) {
    case 'password':
      updateUserPassword(user, 'newPassword123');
      break;
    case 'email':
      updateUserEmail(user, 'newemail@example.com');
      break;
    case 'notify':
      notifyUser(user);
      break;
    default:
      console.log('Invalid update type');
  }
}
```
**Melhorias:** faz apenas uma coisa por fun√ß√£o, o nome est√° descritivo, sem efeitos colaterais, sem flags desnecess√°rias e o c√≥digo duplicado foi removido.

---

<h2 id="descricao"> 5. Coment√°rios</h2>

Coment√°rios devem ser evitados sempre que o c√≥digo puder ser autoexplicativo. Refatorar o c√≥digo para torn√°-lo claro √© prefer√≠vel a adicionar coment√°rios explicativos. Nomes descritivos para fun√ß√µes, vari√°veis e classes podem substituir a maioria dos coment√°rios, tornando o c√≥digo mais leg√≠vel e menos propenso a se tornar desatualizado.

Coment√°rios s√≥ s√£o √∫teis em casos de l√≥gica de neg√≥cio complexa ou para alertar sobre algo espec√≠fico e potencialmente problem√°tico. Coment√°rios como TODO podem ser usados para marcar √°reas que precisam de aten√ß√£o futura.

Evite manter c√≥digo comentado na base de c√≥digo e n√£o registre altera√ß√µes diretamente nos coment√°rios, pois o controle de vers√£o j√° lida com isso. N√£o use marcadores de posi√ß√£o, como linhas de divis√£o, para separar se√ß√µes do c√≥digo.

**Exemplo ruim:**

```javascript
function calculateHash(data) {
  // Cria uma hash
  let hash = 0;

  // Comprimento da string
  const length = data.length;

  // Loop em cada caractere
  for (let i = 0; i < length; i++) {
    // Pega o c√≥digo do caractere
    const char = data.charCodeAt(i);
    // Gera a hash
    hash = ((hash << 5) - hash) + char;
    // Converte para inteiro 32-bit
    hash &= hash;
  }

  // TODO: adicionar suporte a outras codifica√ß√µes
  return hash;
}

// doSomeWork();
// doOtherStuff();  // c√≥digo desnecess√°rio comentado

/**
 * 2023-08-17: Adicionada fun√ß√£o de hash (TS)
 * 2023-07-22: Melhorada fun√ß√£o de hash (JP)
 */
function combine(a, b) {
  return a + b;
}

////////////////////////////////////////////////////////////////////////////////
// Configura√ß√£o inicial do sistema
////////////////////////////////////////////////////////////////////////////////
const config = {
  retries: 5,
  timeout: 2000
};
```
**Problemas:** coment√°rios explicando o √≥bvio (como "Cria uma hash"), c√≥digo comentado deixado na base de c√≥digo, registro de altera√ß√µes desnecess√°rio e marcadores de posi√ß√£o sem valor real


---

**Exemplo correto segundo clean code:**
```javascript
function calculateHash(data) {
  let hash = 0;
  const length = data.length;

  for (let i = 0; i < length; i++) {
    const char = data.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash &= hash;  // Converte para 32-bit
  }

  return hash;
}

function combine(a, b) {
  return a + b;
}

const config = {
  retries: 5,
  timeout: 2000
};
```

**Melhorias:** sem coment√°rios desnecess√°rios, remo√ß√£o do c√≥digo comentado, sem registros de altera√ß√µes no c√≥digo e elimina√ß√£o de mercadores de posi√ß√£o.

---

<h2 id="descricao"> 6. Formata√ß√£o </h2>

A formata√ß√£o √© essencial para garantir um c√≥digo leg√≠vel e profissional. Um c√≥digo bem formatado facilita a leitura, a manuten√ß√£o e reflete o cuidado do desenvolvedor. Arquivos menores, bem divididos, s√£o mais f√°ceis de gerenciar. Ferramentas autom√°ticas de formata√ß√£o, como linters e formatadores, s√£o recomendadas para evitar discuss√µes desnecess√°rias sobre estilo.

Seja consistente com a capitaliza√ß√£o em vari√°veis, fun√ß√µes e classes. Fun√ß√µes e chamadas de fun√ß√µes devem estar pr√≥ximas verticalmente para facilitar a leitura, respeitando o fluxo natural de leitura de cima para baixo.

**Exemplo ruim:**

```javascript
const ITEMS_IN_CART = 3;
const items_in_stock = 50;

const products = ['Laptop', 'Smartphone', 'Headphones'];
const Categories = ['Electronics', 'Accessories', 'Home Appliances'];

function place_order() {}
function cancel_order() {}

class user {}
class Order {}

class OrderManager {
  constructor(order) {
    this.order = order;
  }

  checkStock() {
    return db.lookup(this.order, 'stock');
  }

  getOrderDetails() {
    const stock = this.checkStock();
    // ...
  }

  processOrder() {
    this.getOrderDetails();
    this.sendInvoice();
    this.updateStock();
  }

  sendInvoice() {
    // ...
  }

  updateStock() {
    const stock = this.checkStock();
  }
}

const orderManager = new OrderManager(order);
orderManager.processOrder();
```

**Problemas:** inconsist√™ncia na capitaliza√ß√£o de vari√°veis, fun√ß√µes e classes, fun√ß√µes e chamadas de fun√ß√µes est√£o separadas, dificultando a leitura do fluxo, e a fun√ß√£o processOrder deveria estar mais pr√≥xima de suas depend√™ncias.

---

**Exemplo correto segundo clean code:**
```javascript
const ITEMS_IN_CART = 3;
const ITEMS_IN_STOCK = 50;

const PRODUCTS = ['Laptop', 'Smartphone', 'Headphones'];
const CATEGORIES = ['Electronics', 'Accessories', 'Home Appliances'];

function placeOrder() {}
function cancelOrder() {}

class User {}
class Order {}

class OrderManager {
  constructor(order) {
    this.order = order;
  }

  processOrder() {
    this.getOrderDetails();
    this.sendInvoice();
    this.updateStock();
  }

  getOrderDetails() {
    const stock = this.checkStock();
    // ...
  }

  checkStock() {
    return db.lookup(this.order, 'stock');
  }

  sendInvoice() {
    // ...
  }

  updateStock() {
    const stock = this.checkStock();
    // ...
  }
}

const orderManager = new OrderManager(order);
orderManager.processOrder();
```

**Melhorias:** A capitaliza√ß√£o est√° consistente, teve um uso adequado de mai√∫sculas e min√∫sculas nas vari√°veis, fun√ß√µes e classes, como ITEMS_IN_STOCK e placeOrder. A fun√ß√£o processOrder est√° diretamente acima das fun√ß√µes auxiliares que ela utiliza, como getOrderDetails, sendInvoice, e updateStock, facilitando o fluxo de leitura. O c√≥digo segue uma estrutura l√≥gica de cima para baixo, refletindo um fluxo claro e f√°cil de entender.

---

<h2 id="descricao"> 7. Objetos e Estruturas de Dados </h2>

Objetos exp√µem as a√ß√µes e ocultam os dados, o que facilita a adi√ß√£o de novos tipos de objetos sem precisar modificar as a√ß√µes existentes, mas torna mais dif√≠cil a inclus√£o de novas atividades em objetos j√° existentes. Por outro lado, estruturas de dados exp√µem os dados e n√£o possuem a√ß√µes significativas, facilitando a adi√ß√£o de novas a√ß√µes √†s estruturas de dados existentes, mas dificultando a inclus√£o de novas estruturas de dados em fun√ß√µes existentes.

Em um sistema, a escolha entre objetos e estruturas de dados depende da flexibilidade desejada. Quando se busca flexibilidade para adicionar novos tipos de dados, a op√ß√£o por objetos √© mais adequada. Quando a necessidade √© adicionar novas a√ß√µes, optar por tipos de dados e procedimentos faz mais sentido.

Utilizar getters e setters em objetos √© uma pr√°tica recomendada porque oferece v√°rias vantagens, como facilitar a modifica√ß√£o do comportamento dos acessos aos dados sem alterar os pontos de chamada no c√≥digo, permite adicionar valida√ß√µes ao definir valores (set), por encapsular a representa√ß√£o interna dos dados promove maior flexibilidade, e torna mais f√°cil adicionar logs e tratamentos de erros.

**Exemplo ruim:**

```javascript
function createProduct() {
  return {
    stock: 0, // Propriedade p√∫blica
  };
}

const product = createProduct();
product.stock = 50; // Modifica√ß√£o direta
```

**Exemplo correto segundo clean code:**
```javascript
function createProduct() {
  // Propriedade privada
  let stock = 0;

  // Getter para acessar o estoque
  function getStock() {
    return stock;
  }

  // Setter para modificar o estoque, com valida√ß√£o
  function setStock(quantity) {
    if (quantity < 0) {
      throw new Error("A quantidade de estoque n√£o pode ser negativa");
    }
    stock = quantity;
  }

  return {
    getStock,
    setStock,
  };
}

const product = createProduct();
product.setStock(50); // Modifica√ß√£o controlada
console.log(product.getStock()); // Acesso controlado
```

---

<h2 id="descricao"> 8. Tratamento de Erro </h2>

Usar exce√ß√µes √© prefer√≠vel a retornar c√≥digos de erro ou null, pois facilita a identifica√ß√£o e o tratamento de problemas. Exce√ß√µes tornam o c√≥digo mais leg√≠vel e robusto, separando a l√≥gica principal do tratamento de erros. Evitar o uso de null como retorno ou argumento √© crucial para prevenir erros inesperados, e o uso de objetos de caso especial pode eliminar a necessidade de verifica√ß√µes constantes de null.

Sempre trate erros capturados em try/catch com a√ß√µes concretas, como logar adequadamente, notificar o usu√°rio ou enviar relat√≥rios para servi√ßos de monitoramento. N√£o ignore promessas rejeitadas em c√≥digo ass√≠ncrono.

**Exemplo ruim:**
```javascript
function processOrder(order) {
  const customer = getCustomer(order.id);
  if (customer !== null) {
    const paymentMethod = customer.getPaymentMethod();
    if (paymentMethod !== null) {
      if (!paymentMethod.isValid()) {
        console.log("Invalid payment method");
      } else {
        completeOrder(order);
      }
    } else {
      console.log("Payment method is null");
    }
  } else {
    console.log("Customer not found");
  }
}

getOrderData()
  .then((order) => {
    processOrder(order);
  })
  .catch((error) => {
    console.log("Error processing order:", error);
  });

try {
  updateInventory();
} catch (error) {
  console.log(error);
}
```
**Problemas:** faz uso de null como valor de retorno e muitas verifica√ß√µes de null,tratamento de erros com console.log, que n√£o oferece um plano real de a√ß√£o e  promessa rejeitada √© tratada com console.log, o que pode ser facilmente ignorado.

---

**Exemplo correto segundo clean code:**
```javascript
function processOrder(order) {
  const customer = getCustomer(order.id) || new NullCustomer();
  const paymentMethod = customer.getPaymentMethod() || new NullPaymentMethod();

  if (!paymentMethod.isValid()) {
    throw new Error("Invalid payment method");
  }

  completeOrder(order);
}

getOrderData()
  .then((order) => {
    processOrder(order);
  })
  .catch((error) => {
    console.error("Error processing order:", error);
    notifyUserOfError(error);
    reportErrorToService(error);
  });

try {
  updateInventory();
} catch (error) {
  console.error("Inventory update failed:", error);
  reportErrorToService(error);
}
```

**Melhorias:** NullCustomer e NullPaymentMethod eliminam a necessidade de verifica√ß√µes de null. Em vez de console.log, o c√≥digo usa console.error, notifica√ß√£o ao usu√°rio e relat√≥rios para um servi√ßo, fornecendo um plano de a√ß√£o claro. Promessas rejeitadas s√£o tratadas com a√ß√µes adequadas, como logar, notificar e reportar, em vez de simplesmente ignorar.

---

<h2 id="descricao"> 9. Limites </h2>

Ao integrar bibliotecas de terceiros, √© importante entender seu funcionamento por meio de "testes de aprendizagem". Esses testes permitem explorar o comportamento da API sem comprometer a l√≥gica principal da aplica√ß√£o. Uma vez que a funcionalidade √© compreendida, encapsule o uso da biblioteca em fun√ß√µes ou classes reutiliz√°veis para manter a configura√ß√£o centralizada e clara.

**Exemplo ruim:**

```javascript
const winston = require('winston');

// Tentativa direta de uso da biblioteca sem testes ou estrutura clara
const logger = winston.createLogger({
    level: 'info',
    transports: [
        new winston.transports.Console()
    ]
});

logger.info('Logging direto sem testes.');

const anotherLogger = winston.createLogger({
    level: 'debug',
    transports: [
        new winston.transports.Console()
    ]
});

anotherLogger.debug('Outro logger sem configura√ß√£o centralizada.');
```

**Problemas:** Uso direto da biblioteca sem testes para entender o comportamento, duplica√ß√£o de c√≥digo ao criar outro logger com configura√ß√£o similar e configura√ß√£o n√£o centralizada, tornando o c√≥digo mais dif√≠cil de manter e modificar.

---

**Exemplo correto segundo clean code:**

```javascript
const winston = require('winston');

// Teste de aprendizado para explorar a biblioteca de logging
function testLogCreate() {
    const logger = winston.createLogger({
        level: 'info',
        transports: [
            new winston.transports.Console()
        ]
    });
    logger.info('Testando logger b√°sico');
}

function testLogWithCustomFormat() {
    const logger = winston.createLogger({
        level: 'info',
        format: winston.format.combine(
            winston.format.colorize(),
            winston.format.timestamp(),
            winston.format.printf(({ timestamp, level, message }) => {
                return `${timestamp} ${level}: ${message}`;
            })
        ),
        transports: [
            new winston.transports.Console()
        ]
    });
    logger.info('Testando logger com formato personalizado');
}

// Centralizando a cria√ß√£o de loggers para uso em toda a aplica√ß√£o
function createLogger() {
    return winston.createLogger({
        level: 'info',
        format: winston.format.combine(
            winston.format.colorize(),
            winston.format.timestamp(),
            winston.format.printf(({ timestamp, level, message }) => {
                return `${timestamp} ${level}: ${message}`;
            })
        ),
        transports: [
            new winston.transports.Console()
        ]
    });
}

const logger = createLogger();
logger.info('Logger pronto para uso na aplica√ß√£o.');
```

**Melhorias:** Foram criados testes para entender o comportamento do logger antes da implementa√ß√£o definitiva, a cria√ß√£o do logger foi centralizada em uma fun√ß√£o, eliminando a duplica√ß√£o e facilitando a manuten√ß√£o e a fun√ß√£o createLogger permite a reutiliza√ß√£o da l√≥gica de configura√ß√£o em toda a aplica√ß√£o.

---

<h2 id="descricao"> 10. Testes de Unidade </h2>

Testes de unidade s√£o essenciais para garantir que o c√≥digo de produ√ß√£o seja flex√≠vel e f√°cil de modificar. Testes claros e bem escritos permitem que os desenvolvedores fa√ßam mudan√ßas com confian√ßa, sabendo que erros ser√£o detectados rapidamente. Para manter a qualidade, os testes devem ser r√°pidos, independentes, repet√≠veis, autovalidados e escritos no momento certo.

Al√©m disso, cada teste deve se focar em um conceito por vez, evitando c√≥digo duplicado ou complexidade desnecess√°ria.

**Exemplo ruim:**

```javascript
import assert from 'assert';

describe('InventoryManager', () => {
  it('handles item stock and pricing', () => {
    let item = new InventoryManager('Laptop');
    item.addStock(50);
    assert.equal(item.getStock(), 50);

    item.setPrice(1200);
    assert.equal(item.getPrice(), 1200);

    item = new InventoryManager('Smartphone');
    item.addStock(30);
    assert.equal(item.getStock(), 30);

    item.setPrice(800);
    assert.equal(item.getPrice(), 800);
  });
});

import { get } from 'request';
import { writeFile } from 'fs';

get('https://api.shop.com/inventory', (requestErr, response) => {
  if (requestErr) {
    console.error(requestErr);
  } else {
    writeFile('inventory.json', response.body, (writeErr) => {
      if (writeErr) {
        console.error(writeErr);
      } else {
        console.log('File written');
      }
    });
  }
});
```
**Problemas:** os testes est√£o complexos por que possuem v√°rios conceitos testados na mesma fun√ß√£o, como estoque e pre√ßo. O c√≥digo tamb√©m est√° aninhado e dif√≠cil de manter com callbacks.

**Exemplo correto segundo clean code:**
```javascript
import assert from 'assert';

describe('InventoryManager', () => {
  it('handles item stock', () => {
    const item = new InventoryManager('Laptop');
    item.addStock(50);
    assert.equal(item.getStock(), 50);
  });

  it('handles item pricing', () => {
    const item = new InventoryManager('Laptop');
    item.setPrice(1200);
    assert.equal(item.getPrice(), 1200);
  });

  it('handles different items stock', () => {
    const item = new InventoryManager('Smartphone');
    item.addStock(30);
    assert.equal(item.getStock(), 30);
  });

  it('handles different items pricing', () => {
    const item = new InventoryManager('Smartphone');
    item.setPrice(800);
    assert.equal(item.getPrice(), 800);
  });
});

import { get } from 'request-promise';
import { writeFile } from 'fs-promise';

async function fetchInventory() {
  try {
    const response = await get('https://api.shop.com/inventory');
    await writeFile('inventory.json', response);
    console.log('File written');
  } catch (err) {
    console.error(err);
  }
}
```

**Melhorias:** os testes est√£o agora divididos por conceitos e foi simplificado com async/await, eliminando aninhamento de callbacks e melhorando a legibilidade.

---

<h2 id="descricao"> 11. Classes </h2>

Classes devem ser pequenas, focadas em uma √∫nica responsabilidade e coesas, seguindo o Princ√≠pio da Responsabilidade √önica (SRP). Isso facilita a manuten√ß√£o e evita a necessidade de modifica√ß√µes frequentes. Organize m√©todos relacionados pr√≥ximos uns dos outros e prefira composi√ß√£o sobre heran√ßa, sempre que poss√≠vel. Al√©m disso, utilize padr√µes de design como inje√ß√£o de depend√™ncia e o princ√≠pio do aberto/fechado para criar classes extens√≠veis sem a necessidade de alterar c√≥digo existente.

**Exemplo ruim:**

```javascript
class Car {
  constructor(brand, model, year) {
    this.brand = brand;
    this.model = model;
    this.year = year;
    this.color = null;
  }

  setColor(color) {
    this.color = color;
  }

  saveCar() {
    console.log(`Saving ${this.brand} ${this.model}`);
  }

  updatePrice(price) {
    console.log(`Updated price to ${price}`);
  }

  calculateDepreciation() {
    const currentYear = new Date().getFullYear();
    const depreciation = (currentYear - this.year) * 0.1;
    console.log(`Depreciation: ${depreciation}`);
  }
}

const car = new Car('Tesla', 'Model S', 2020);
car.setColor('red');
car.saveCar();
car.updatePrice(70000);
car.calculateDepreciation();
```

**Problemas:** falta coes√£o por que a classe `car` est√° realizando m√∫ltiplas responsabilidades, como c√°lculo de deprecia√ß√£o e gerenciamento de pre√ßos. H√° tamb√©m duplica√ß√£o no c√≥digo por que m√©todos n√£o relacionados est√£o centralizados em uma classe, dificultando a manuten√ß√£o.

---

**Exemplo correto segundo clean code:**

```javascript
class Car {
  constructor(brand, model, year) {
    this.brand = brand;
    this.model = model;
    this.year = year;
    this.color = null;
  }

  setColor(color) {
    this.color = color;
    return this;  // Para encadeamento de m√©todos
  }

  save() {
    console.log(`Saving ${this.brand} ${this.model}`);
    return this;
  }
}

class CarPricing {
  constructor(car) {
    this.car = car;
  }

  updatePrice(price) {
    console.log(`Updated price for ${this.car.brand} ${this.car.model} to ${price}`);
  }
}

class DepreciationCalculator {
  constructor(car) {
    this.car = car;
  }

  calculate() {
    const currentYear = new Date().getFullYear();
    const depreciation = (currentYear - this.car.year) * 0.1;
    console.log(`Depreciation: ${depreciation}`);
  }
}

// Uso
const car = new Car('Tesla', 'Model S', 2020)
  .setColor('blue')
  .save();

const pricing = new CarPricing(car);
pricing.updatePrice(75000);

const depreciation = new DepreciationCalculator(car);
depreciation.calculate();
```

**Melhorias:** agora o c√≥digo est√° visando a responsabilidade √∫nica, visto que foi feito a divis√£o da l√≥gica entre classes Car, CarPricing e DepreciationCalculator, cada uma focada em uma responsabilidade √∫nica. O m√©todo setColor retorna this, permitindo encadeamento de m√©todos. Foi utilizado composi√ß√£o ao inv√©s de heran√ßa, para separar funcionalidades como c√°lculo de deprecia√ß√£o e gest√£o de pre√ßos.

---

<h2 id="descricao"> 12. Sistemas </h2>

> "Complexidade mata. Ela suga a vida dos desenvolvedores, dificulta o planejamento, a constru√ß√£o e o teste dos produtos‚Äù.
> ‚ÄîRay Ozzie, CTO, Microsoft Corporation

Assim como na constru√ß√£o de uma cidade, em software devemos dividir responsabilidades entre diferentes m√≥dulos e classes, mantendo a complexidade sob controle. Isso facilita o desenvolvimento, manuten√ß√£o e evolu√ß√£o do sistema. A separa√ß√£o entre a constru√ß√£o de objetos e o uso do sistema √© essencial. A inicializa√ß√£o e configura√ß√£o de depend√™ncias devem ficar em uma camada externa, geralmente no arquivo principal (main), que instanciar√° os objetos e passar√° as depend√™ncias, desacoplando a l√≥gica de neg√≥cio da l√≥gica de constru√ß√£o.

Inje√ß√£o de Depend√™ncia (DI) √© uma t√©cnica √∫til para desacoplar componentes, permitindo maior flexibilidade e testabilidade. Com DI, as depend√™ncias s√£o passadas para as classes via construtores ou setters, em vez de serem criadas internamente, facilitando a reutiliza√ß√£o do c√≥digo.

A evolu√ß√£o do sistema deve ser incremental. Inicie com uma arquitetura m√≠nima e refatore conforme novas funcionalidades s√£o adicionadas, seguindo os princ√≠pios √°geis. Padr√µes como Factory e DI s√£o √∫teis para tornar o c√≥digo modular e f√°cil de manter, mas devem ser usados com modera√ß√£o, apenas quando trazem valor real ao projeto.

**Exemplo ruim:**

```javascript
class LineItem {
  constructor(product, quantity) {
    this.product = product;
    this.quantity = quantity;
  }
}

class Order {
  constructor() {
    this.items = [];
  }

  addItem(product, quantity) {
    const item = new LineItem(product, quantity);
    this.items.push(item);
  }

  processOrder() {
    console.log("Order processed");
  }
}

const order = new Order();
order.addItem("Product A", 5);
order.processOrder();
```

**Problemas:** existe uma alta acoplagem por que a classe Order cria diretamente os objetos LineItem, dificultando a reutiliza√ß√£o e a testabilidade. A responsabilidade de instanciar LineItem deveria ser separada da l√≥gica de Order.

---

**Exemplo correto segundo clean code:**

```javascript
class LineItem {
  constructor(product, quantity) {
    this.product = product;
    this.quantity = quantity;
  }
}

class LineItemFactory {
  create(product, quantity) {
    return new LineItem(product, quantity);
  }
}

class Order {
  constructor(itemFactory) {
    this.items = [];
    this.itemFactory = itemFactory;
  }

  addItem(product, quantity) {
    const item = this.itemFactory.create(product, quantity);
    this.items.push(item);
  }

  processOrder() {
    console.log("Order processed");
  }
}

// Separa√ß√£o no main
const factory = new LineItemFactory();
const order = new Order(factory);
order.addItem("Product A", 5);
order.processOrder();
```

**Melhorias:** a cria√ß√£o de LineItem foi movida para a LineItemFactory, desacoplando a l√≥gica de cria√ß√£o da classe Order. Order recebe a LineItemFactory via seu construtor, permitindo maior flexibilidade e testabilidade.

---

<h2 id="descricao"> 13. Emerg√™ncia </h2>

Seguir regras simples pode ajudar a criar bons designs de software. Kent Beck sugere as Quatro Regras do Projeto Simples para auxiliar no desenvolvimento de projetos claros e eficazes:

- **Efetuar todos os testes:** O c√≥digo deve funcionar conforme o esperado. Ter um sistema test√°vel for√ßa o desenvolvedor a criar classes pequenas e com uma √∫nica responsabilidade, facilitando o uso de princ√≠pios como SRP e DIP.

- **Eliminar duplica√ß√£o de c√≥digo:** Duplica√ß√£o de c√≥digo gera complexidade desnecess√°ria. Remova duplica√ß√µes, mesmo que sejam pequenas, para manter o c√≥digo limpo e eficiente.

- **Expressar a inten√ß√£o do programador:** O c√≥digo deve ser claro, com nomes descritivos para classes e fun√ß√µes. Pequenas classes e fun√ß√µes s√£o mais f√°ceis de entender e mant√™-las expressivas reduz o custo de manuten√ß√£o.

- **Minimizar o n√∫mero de classes e m√©todos:** Embora devamos eliminar duplica√ß√µes e manter o c√≥digo expressivo, √© importante n√£o exagerar na cria√ß√£o de classes e m√©todos pequenos. A simplicidade deve ser o objetivo.

**Exemplo ruim:**

```javascript
class ImageProcessor {
  scaleImage(desiredDimension, imageDimension) {
    if (Math.abs(desiredDimension - imageDimension) < 0.01) return;
    let scalingFactor = desiredDimension / imageDimension;
    scalingFactor = Math.floor(scalingFactor * 100) * 0.01;
    const newImage = this.getScaledImage(scalingFactor);
    this.image.dispose();
    System.gc();
    this.image = newImage;
  }

  rotateImage(degrees) {
    const newImage = this.getRotatedImage(degrees);
    this.image.dispose();
    System.gc();
    this.image = newImage;
  }

  getScaledImage(factor) { /* ... */ }

  getRotatedImage(degrees) { /* ... */ }
}
```

**Problemas:** a l√≥gica de substitui√ß√£o de imagem √© repetida nas fun√ß√µes scaleImage e rotateImage e isso gera duplica√ß√£o. Existe uma baixa expressividade por que as fun√ß√µes fazem muito e os nomes n√£o refletem totalmente suas responsabilidades.

---

**Exemplo correto segundo clean code:**

```javascript
class ImageProcessor {
  replaceImage(newImage) {
    this.image.dispose();
    System.gc();
    this.image = newImage;
  }

  scaleImage(desiredDimension, imageDimension) {
    if (Math.abs(desiredDimension - imageDimension) < 0.01) return;
    let scalingFactor = Math.floor((desiredDimension / imageDimension) * 100) * 0.01;
    this.replaceImage(this.getScaledImage(scalingFactor));
  }

  rotateImage(degrees) {
    this.replaceImage(this.getRotatedImage(degrees));
  }

  getScaledImage(factor) { /* ... */ }

  getRotatedImage(degrees) { /* ... */ }
}
```

**Melhorias:** A l√≥gica de substitui√ß√£o de imagem foi movida para o m√©todo replaceImage, eliminando duplica√ß√£o. Fun√ß√µes s√£o menores e focadas, tornando o c√≥digo mais leg√≠vel e claro, trazendo Expressividade.

---

<h2 id="descricao"> 14. Concorr√™ncia</h2>

Escrever programas concorrentes limpos √© um desafio. Concorr√™ncia ajuda a desacoplar a execu√ß√£o de tarefas, mas requer cuidados extras com bugs dif√≠ceis de reproduzir, como deadlocks e race conditions.

Concorr√™ncia n√£o sempre melhora o desempenho. Ela funciona bem apenas em casos onde h√° longas esperas ou ociosidade de processadores. Al√©m disso, o design de projetos concorrentes frequentemente exige uma abordagem diferente, desacoplando o "o que" do "quando." Mesmo com ferramentas como Web containers, √© fundamental entender as quest√µes de concorr√™ncia para evitar deadlocks e garantir integridade.

√â mais eficiente usar Promessas em vez de callbacks, que criam complexidade e aninhamentos excessivos. Promessas simplificam o tratamento de erros e tornam o c√≥digo mais leg√≠vel. Al√©m disso, o uso de async/await no ES2017/ES8 oferece uma maneira ainda mais clara e imperativa de lidar com tarefas ass√≠ncronas, eliminando a necessidade de encadeamentos longos de .then().

**Exemplo ruim:**

```javascript
import { get } from 'request';
import { writeFile } from 'fs';

get('https://api.exemplo.com/dados', (err, response) => {
  if (err) {
    console.error(err);
  } else {
    writeFile('dados.json', response.body, (writeErr) => {
      if (writeErr) {
        console.error(writeErr);
      } else {
        console.log('Arquivo salvo');
      }
    });
  }
});
```

**Problemas:** Esse c√≥digo apresenta callbacks aninhados, que aumentam a complexidade, e o tratamento de erros √© disperso, dificultando a leitura e manuten√ß√£o.

---

**Exemplo correto segundo clean code:**

```javascript
import { get } from 'request-promise';
import { writeFile } from 'fs-promise';

async function fetchAndSaveData() {
  try {
    const response = await get('https://api.exemplo.com/dados');
    await writeFile('dados.json', response);
    console.log('Arquivo salvo');
  } catch (err) {
    console.error('Erro ao processar dados:', err);
  }
}

fetchAndSaveData();
```

**Melhorias:** O uso de async/await simplifica a l√≥gica, removendo o aninhamento, e centraliza o tratamento de erros no bloco try/catch, o que facilita o controle e a depura√ß√£o.

---